## Для чего нужен Заместитель
Этот паттерн помогает решить проблемы, связанные с контролируемым доступом к объекту.
При проектировании сложных систем, достаточно часто возникает необходимость обеспечить
контролируемый доступ к определенным объектам системы. Мотивацией для этого служит ряд
приобретаемых преимуществ. Таких как, ленивая инициализация по требованию для 
«громоздких» объектов, подсчет количества ссылок на объект и т.д. и т.п. Однако, 
не всегда потребность в контролируемом доступе к объекту базируется только на 
преимуществах. Как правило, сложность процессов реального мира, ограничения 
вычислительных ресурсов просто не оставляют проектировщику выбора, нежели как 
воспользоваться паттерном ***«Заместитель» («Сурогат»)***.

Идея паттерна **«Заместитель»** заключается в предоставлении клиенту другого объекта 
(заместителя), взамен объекту с контролируемым доступом. При этом, объект-заместитель,
реализует тот-же интерфейс, что и оригинальный объект, в результате чего, поведение
клиента не требует изменений. Иными словами, клиент взаимодействует с заместителем 
ровно как с оригинальным объектом посредством единого интерфейса. Клиент, так же, 
не делает предположений о том работает ли он с реальным объектом или его заместителем. 
Контролирование доступа к объекту, при этом, достигается за счет использования 
ссылки на него в заместителе, благодаря которой заместитель переадресовывает 
внешние вызовы контролируемому объекту, возможно сопровождая их дополнительными 
операциями.

Такой подход позволяет неявным для клиента образом контролировать доступ к объекту.
### Пример 1
Представим, что у нас есть большой проект с кучей старого кода, где есть класс, 
отвечающий за выгрузку отчетов из базы данных. Класс работает синхронно, то есть вся 
система простаивает, пока база обрабатывает запрос. В среднем отчет генерируется 
за 30 минут. Из-за этой особенности его выгрузка запускается в 00:30, и руководство 
получает этот отчет утром.

При анализе выяснилось, что необходимо получать отчет сразу после его генерации, 
то есть в течение дня. Перенести время запуска нельзя, так как система будет ждать 
ответ от базы. Выход — изменить принцип работы, запустив выгрузку и генерацию отчета
в отдельном потоке.

Такое решение позволит системе работать в обычном режиме, а руководство будет 
получать свежие отчеты. Однако есть проблема: текущий код переписывать нельзя, 
так как его функции используют другие части системы.

В этом случае можно ввести промежуточный прокси-класс с помощью паттерна Заместитель,
который будет получать запрос на выгрузку отчета, логировать время начала и 
запускать отдельный поток. Когда отчет сгенерируется, поток завершит свою работу 
и все будут счастливы.
### Пример 2
Команда разработчиков создает сайт-афишу. Чтобы получить данные о новых мероприятиях,
они обращаются к стороннему сервису, взаимодействие с которым реализовано через 
специальную закрытую библиотеку. При разработке появилась проблема: сторонняя система
обновляет данные раз в сутки, а запрос к ней происходит каждый раз, когда 
пользователь обновляет страницу. Это создает большое количество запросов, и сервис 
перестает отвечать.

Решение — кэшировать ответ сервиса и предоставлять посетителям сохраненный результат 
при каждой перезагрузке, обновляя этот кэш по необходимости. В этом случае 
использование паттерна Заместитель — отличное решение без изменения готового 
функционала.
### Принцип работы паттерна
Чтобы внедрить этот паттерн, нужно создать класс-прокси. Он реализует интерфейс 
сервисного класса, имитируя его поведение для клиентского кода. Таким образом вместо
реального объекта клиент взаимодействует с его заместителем. Как правило, все запросы
передаются далее сервисному классу, но с дополнительными действиями до или после его 
вызова.

Проще говоря, этот прокси-объект — прослойка между клиентским кодом и целевым объектом.
![Proxy_pattern_diagram](https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/1200px-Proxy_pattern_diagram.svg.png "Proxy_pattern_diagram")