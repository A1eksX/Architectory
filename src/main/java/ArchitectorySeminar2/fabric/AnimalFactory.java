package ArchitectorySeminar2.fabric;
/*
Паттерн Фабричный - суть в том, что тот кто работает в методе Main, ничего не знает (и не должен знать,
какие классы реализованы. Пользователю только дали название объекта, который он может создать. При этом если сам класс
объекта изменится, то это не затронет клиентский код, т.е. данный паттерн убирает ЖЁСТКУЮ зависимость между классами.
Т.о. получается модульная система где можно изменить клиентский(код в Main) код и он не повлияет на остальную часть кода
и наоборот.
ДО КОНЦА НЕ ПОНЯЛ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
 */

public class AnimalFactory {
    // Фабричный метод, который создает экземпляры подклассов Animal
    public Animal createAnimal(String animalType) {
        if ("dog".equalsIgnoreCase(animalType)) {
            return new Dog();
        } else if ("cat".equalsIgnoreCase(animalType)) {
            return new Cat();
        } else {
            throw new IllegalArgumentException("Неподдерживаемый тип животного");
        }
    }
}
